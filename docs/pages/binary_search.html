<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search: Step-by-Step Working Principle</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles_pages.css">

</head>

<body>
    <!-- Header -->
    <header>
        <div class="container">
            <h1>Doguhan Ilter</h1>
            <p>Software Developer</p>
            <nav>
                <ul>
                    <li><a href="../blogs.html">Notes</a></li>
                    <li><a href="../index.html">Home</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="blog-container">
        <section class="blog-header">
            <h1>Binary Search: Step-by-Step Working Principle</h1>
            <p class="author-date">By Doguhan Ilter | March 2025</p>
        </section>

        <section class="blog-content">
            <h2>What is Binary Search?</h2>
            <p class="corpus">
                Binary Search is a highly efficient algorithm used for finding an element in a sorted array. The core idea is to reduce the search space by half with each step, thus significantly speeding up the process when compared to linear search. The time complexity of Binary Search is <strong>O(log n)</strong>, which is much faster for large datasets than linear search's <strong>O(n)</strong>.
            </p>

            <h2>Why Is Sorting Important?</h2>
            <p class="corpus">
                The fundamental principle behind Binary Search is dividing the search space into halves and then recursively or iteratively narrowing down the search space. This process works only if the array is sorted. If the array is not sorted, we cannot determine whether the next value to search for lies to the left or right of the current middle element. Hence, sorting the array is a prerequisite for Binary Search to function properly.
            </p>
            <p class="corpus">
                In an unsorted array, each element would need to be compared, which leads to a higher time complexity of <strong>O(n)</strong> in the worst case. This is why Binary Search only works with sorted arrays, ensuring that each step brings us closer to the target by eliminating half of the remaining elements.
            </p>

            <h2>The Calculation of <code>int mid = start + (end - start) / 2</code></h2>
            <p class="corpus">
                One critical part of Binary Search is calculating the middle index of the current search range. This can be represented as:
            </p>
            <pre><code>int mid = (start + end) / 2;</code></pre>
            <p class="corpus">
                However, this simple formula may lead to an <strong>overflow</strong> issue if the array is very large. When <code>start</code> and <code>end</code> are large numbers, their sum could exceed the maximum limit of the <code>int</code> type, which causes overflow errors. To prevent this, we use the safer formula:
            </p>
            <pre><code>int mid = start + (end - start) / 2;</code></pre>
            <p class="corpus">
                This formula ensures that the sum of <code>start</code> and <code>end</code> will not overflow. Although both formulas yield the same result when there is no overflow risk, the second one is a more reliable option, especially when working with large arrays.
            </p>

            <h2>Step-by-Step Binary Search Algorithm</h2>
            <p class="corpus">
                Let's break down the working principle of Binary Search step by step.
            </p>
            <ul>
                <li><strong>Step 1:</strong> Start by setting two pointers: <code>start</code> at the beginning of the array and <code>end</code> at the last index of the array.</li>
                <li><strong>Step 2:</strong> Calculate the middle element of the array using the formula <code>mid = start + (end - start) / 2</code>.</li>
                <li><strong>Step 3:</strong> Compare the middle element with the target value.
                    <ul>
                        <li>If the middle element is equal to the target, the search is complete.</li>
                        <li>If the target is less than the middle element, update the <code>end</code> pointer to <code>mid - 1</code> to search the left half of the array.</li>
                        <li>If the target is greater than the middle element, update the <code>start</code> pointer to <code>mid + 1</code> to search the right half of the array.</li>
                    </ul>
                </li>
                <li><strong>Step 4:</strong> Repeat the process until the <code>start</code> pointer exceeds the <code>end</code> pointer, or the element is found.</li>
            </ul>
            <p class="corpus">
                This halving of the search space makes Binary Search a logarithmic time complexity algorithm, making it highly efficient for large datasets.
            </p>

            <h3>Binary Search Example</h3>
            <p class="corpus">
                Let's say we have the following sorted array and we are looking for the number 7:
            </p>
            <pre><code>[1, 3, 5, 7, 9, 11, 13]</code></pre>
            <p class="corpus">
                - Initially, <code>start = 0</code>, <code>end = 6</code>, and <code>mid = (0 + 6) / 2 = 3</code>, so the middle element is 7.
            </p>
            <p class="corpus">
                - Since the middle element is equal to the target (7), the search is complete, and we found the element at index 3.
            </p>

            <h2>Optimizing Binary Search: Edge Cases</h2>
            <p class="corpus">
                While Binary Search is efficient, it is essential to handle edge cases:
            </p>
            <ul>
                <li><strong>Empty Array:</strong> If the array is empty, Binary Search should return a "not found" result immediately.</li>
                <li><strong>Array with One Element:</strong> If the array contains only one element, the algorithm should check if it matches the target value.</li>
                <li><strong>Array with Duplicates:</strong> If the array contains duplicate elements, Binary Search can find the first occurrence or last occurrence depending on the specific requirements of the algorithm.</li>
            </ul>

            <h3>Optimized Code Example</h3>
            <p class="corpus">
                Here's an optimized implementation of Binary Search in JavaScript:
            </p>
            <pre><code>
function binarySearch(arr, target) {
    let start = 0;
    let end = arr.length - 1;
    
    while (start <= end) {
        let mid = start + Math.floor((end - start) / 2);  // Safer mid calculation
        
        if (arr[mid] === target) {
            return mid; // Element found
        } else if (arr[mid] < target) {
            start = mid + 1; // Search the right half
        } else {
            end = mid - 1; // Search the left half
        }
    }
    
    return -1; // Element not found
}
            </code></pre>
            <p class="corpus">
                This function returns the index of the target element if found, or -1 if the element is not present in the array.
            </p>

        </section>

        <section class="blog-footer">
            <p class="footer-text">Binary Search is an essential algorithm for efficient searching in sorted arrays. Its logarithmic time complexity makes it a powerful tool for large datasets. Make sure to handle edge cases and take care in calculating the middle index to avoid overflow errors.</p>
        </section>
    </div>
</body>

</html>
